# **FerrumC Architecture and Dependency Tree**

**Core Philosophy:** Strict unidirectional dependency flow.  
The Golden Rule: Higher layers (Logic/App) depend on Lower layers (Data/Infrastructure). Lower layers never depend on Higher layers.  
The Mechanism: We use Traits defined in Layer 1 to allow Logic (Layer 5\) to use Infrastructure (Layer 4\) without linking against it directly.

## **Layer 1: The Primitives (Pure Rust)**

*These crates have minimal dependencies. They define the "Language" of the server.*

### **ferrumc-core**

* **Purpose:** The absolute source of truth. Defines data structures and **Behavioral Traits**. Contains **NO** Bevy or Tokio logic.  
* **Contents:**  
  * **Math:** BlockPos, ChunkPos, AABB, Rotation.  
  * **World Data:** Chunk, Section, BlockStates, Palette structs.  
  * **Items/Entities:** ItemID (i32), InventorySlot, EntityType, EntityData.  
  * **Interfaces (The Bridge):**  
    * trait PacketSender: Allows logic to send packets without knowing about TCP.  
    * trait ChunkSource: Allows logic (like WorldGen) to read chunks without knowing about LMDB.  
    * trait CommandExecutor: Allows infrastructure to trigger game commands.

### **ferrumc-utils**

* **Purpose:** General helper functions.  
* **Contents:** Logging setup, Config parsing (serde), ThreadPools, Error handling.

### **ferrumc-macros**

* **Purpose:** Boilerplate reduction.  
* **Contents:** NetEncode, NetDecode, and NBTSerialize derive macros.

### **ferrumc-nbt**

* **Purpose:** File format handling.  
* **Contents:** NBT parsing/serialization logic.

## **Layer 2: The Definitions (Static & Wire)**

*These crates define the static data and network standards. They depend on Layer 1\.*

### **ferrumc-registry**

* **Purpose:** Fast, read-only access to static game data loaded at startup.  
* **Contents:** Compile-time maps for Block IDs, Item Names, Hardness, Physics properties.  
* **Note:** Generated by tools/data-gen. Depends on core types.

### **ferrumc-protocol**

* **Purpose:** Defines the wire format of every network packet.  
* **Contents:** Structs for ChunkDataPacket, PlayerActionPacket, etc. Implementation of NetEncode/NetDecode traits.  
* **Critical Rule:** Depends on ferrumc-core (for types like BlockPos/Chunk), but **NOT** on ferrumc-ecs or ferrumc-net.

## **Layer 3: The Engine State (ECS Schema)**

*These* crates define how the game state is represented in memory. *They depend on Layers 1 & 2 \+ Bevy.*

### **ferrumc-ecs**

* **Purpose:** The single source of truth for the ECS schema. Merges Components and Messages.  
* **Contents:**  
  * **Components:** Position, Health, Inventory, NetworkConnection (holds Box\<dyn PacketSender\>).  
  * **Messages (Events):** PlayerJoin, BlockBreak, Chat, EntityMove, **PacketReceived\<P\>** (wraps Layer 2 Protocol structs).  
  * **Resources:** ServerState (holds Box\<dyn ChunkSource\>), PlayerList.

### **ferrumc-api**

* **Purpose:** A facade crate that re-exports safe, stable types for 3rd party developers.  
* **Contents:** The public-facing SDK.

## **Layer 4: The Infrastructure (Heavy I/O)**

*These crates handle heavy asynchronous operations. They IMPLEMENT the Traits defined in Layer 1\.*

### **ferrumc-net**

* **Purpose:** Manages TCP/IP, Encryption, and Compression.  
* **Contents:** Tokio Runtime, Connection Listener, Packet Deserializer.  
* **Implements:** PacketSender (The concrete implementation uses Tokio channels).  
* **Flow:** deserializes bytes into ferrumc-protocol structs \-\> wraps them in ferrumc-ecs Events \-\> fires into App.

### **ferrumc-storage**

* **Purpose:** Manages disk persistence.  
* **Contents:** LMDB database wrappers, Anvil Region importing, Caching strategies.  
* **Implements:** ChunkSource (The concrete implementation uses LMDB/Moka).

### **ferrumc-management**

* **Purpose:** The Control Plane.  
* **Contents:** JSON-RPC over WebSocket/HTTP for external admin tools.

## **Layer 5: Game Logic (The Modules)**

*The* actual gameplay code. Runs as Bevy Systems. Organized by *Feature.*

### **ferrumc-modules (Workspace)**

* **Dependency Rule:** Depends on ferrumc-core, ferrumc-ecs, ferrumc-registry, ferrumc-protocol. Does **NOT** depend on net or storage directly (uses Traits).

#### **Sub-Crates:**

* **movement**: Validates player position, physics, and collision.  
* **mining**: Handles digging timing, drops, and tool durability.  
  * *Logic:* Fires BlockBreakEvent.  
* **interactions**: Item usage, eating, inventory management.  
* **world\_gen**: Generates terrain.  
  * *Access:* Uses Res\<ServerState\> \-\> Box\<dyn ChunkSource\> to check neighbors.  
* **replication**: The "View" Layer.  
  * *Role:* Listens for ECS changes and syncs them to clients.  
  * *State Sync:* Changed\<Health\> \-\> Sends UpdateHealthPacket.  
  * *Spatial Sync:* BlockBreakEvent \-\> Calculates chunk viewers \-\> Sends BlockUpdatePacket.

## **Layer 6: The Assembler (The Binary)**

### **ferrumc-server (bin)**

* **Purpose:** Dependency Injection Root.  
* **Contents:**  
  1. **Init:** Loads Config, Logger, Registry.  
  2. **Infra:** Initializes ferrumc-net and ferrumc-storage.  
  3. **Injection:** Wraps infrastructure in Box\<dyn Trait\> and inserts into ServerState.  
  4. **Registration:** Adds ferrumc-modules plugins to the App.  
  5. **Run:** Starts the loop.  
* **Rule:** Contains **NO** game logic.